<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[A Developer's Blog]]></title>
  <link href="http://tlarrieu.github.io/atom.xml" rel="self"/>
  <link href="http://tlarrieu.github.io/"/>
  <updated>2019-01-08T00:05:56+01:00</updated>
  <id>http://tlarrieu.github.io/</id>
  <author>
    <name><![CDATA[Thomas Larrieu]]></name>
    <email><![CDATA[thomas.larrieu@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[I'm not an impostor.]]></title>
    <link href="http://tlarrieu.github.io/blog/2014/08/31/impostor-syndrome/"/>
    <updated>2014-08-31T11:42:10+02:00</updated>
    <id>http://tlarrieu.github.io/blog/2014/08/31/impostor-syndrome</id>
    <content type="html"><![CDATA[<p>From <a href="http://en.wikipedia.org/wiki/Impostor_syndrome">Wikipedia</a> :</p>

<blockquote><p>The impostor syndrome, sometimes called impostor phenomenon or fraud syndrome,
is a psychological phenomenon in which people are unable to <strong>internalize
their accomplishments</strong>. Despite external <strong>evidence of their competence</strong>,
those with the syndrome remain convinced that they are frauds and do not
deserve the success they have achieved. Proof of success is dismissed as luck,
timing, or as a result of deceiving others into thinking they are more
intelligent and competent than they believe themselves to be.</p></blockquote>

<p>In today&rsquo;s article, I want to talk about a phenomenon that I&rsquo;ve been recently
made aware of.</p>

<!-- more -->


<p>I&rsquo;ve been working for eight months straight here at <a href="http://www.shopmium.com">Shopmium</a>.
And I have to say, everything has been going pretty smoothly : I&rsquo;ve become
somewhat competent with both Rails and the business the company is involved in.
I&rsquo;ve even been entitled with more responsabilities. I review code and get
asked questions on a daily basis.</p>

<p>But for some reason, up until a month or two, I&rsquo;ve been feeling kind of awkward.
God knows why, I kept telling myself that I was not doing a good job. Making
some mistakes sure did not help.</p>

<p>In fact, that&rsquo;s this <a href="https://www.youtube.com/watch?v=l_Vqp1dPuPo">talk</a> talk
that made me realize why. Our brain seems to focus more on failures than on
successes. No matter what we accomplish, it manages somehow to give us plenty of
reasons to feel bad about what we do. The one great lesson I learned upon
viewing this talk is that no matter what, we have to :</p>

<ol>
<li> Embrace failure. It happens to everyone. You might even learns things from it.</li>
<li> Look on the bright side. At the end of the day, you are not the complete fraud
your brains keeps trying to make you think you are.</li>
</ol>


<p>That, of course, does not mean you should not care about what you are doing. Feeling
bad for doing mistakes is still right.</p>

<p>Just stop bashing your head against the walls !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sharpening your tools]]></title>
    <link href="http://tlarrieu.github.io/blog/2014/02/25/sharpening-your-tools/"/>
    <updated>2014-02-25T19:46:12+01:00</updated>
    <id>http://tlarrieu.github.io/blog/2014/02/25/sharpening-your-tools</id>
    <content type="html"><![CDATA[<p>In a recent <a href="http://tlarrieu.github.io/blog/2014/01/18/the-proper-tools-to-get-things-done">article</a>, I
was talking about tools.  In this one, I will be speaking about sharpening them.</p>

<p>Recently, I was made aware of something terrible : my workflow is <em>clunky</em>. Or
should I say, not optimized. I often find myself repeating the same operations
throughout the day, involving lots of keystrokes. And up until now, I did not
make a big fuss about it.</p>

<!-- more -->


<p>Of course, I regularly spent time — and I still do, tailoring my vimrc. Of course
I have a few aliases in my shell configuration. But I somewhat discovered that I
was not so much aggressive about diminishing the number of keystrokes. A few
days ago, I stumbled upon this
<a href="http://rubyrogues.com/129-rr-sharpening-tools-with-ben-orenstein/">podcast</a>.
And it changed my whole vision about the situation. I already had the opportunity
to listen to <a href="https://github.com/r00k">Ben</a> talking about this alongside his talks.
But this did not struck me much, God knows why.</p>

<p>I have aquired the certitude that small things matters. From this day on, I took
one simple resolution : <em>improve my workflow</em>. Little by little, smoothen and
take good care of it.</p>

<p>In practice, here is what I do : everytime I notice something wrong about what
I am doing, something that makes me feel I could do it quicker, I either fix it
immediately, taking around ten minutes to do so, or write it on my
“build-an-awesome-workflow-todo-list”. Every morning, I spend ten to twenty
minutes to remove as much as I can from this list, prior to the morning stand-up,
right before starting to work.</p>

<p>This has two great impacts on my day : first and foremost, it improves my
productivity — well, this was kind of intended! — making me more efficient. But
it has another effect : I start my day on a positive note, no matter what the
day before was made of. I could have spent an horrible day trying to fix a bug
that I quiet did not manage to catch yet, and still start the day on the right
foot.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Diving into code]]></title>
    <link href="http://tlarrieu.github.io/blog/2014/01/25/diving-into-code/"/>
    <updated>2014-01-25T00:10:51+01:00</updated>
    <id>http://tlarrieu.github.io/blog/2014/01/25/diving-into-code</id>
    <content type="html"><![CDATA[<p>After a month here at <a href="http://www.shopmium.com">Shopmium</a>, I can say I&rsquo;ve been
through a pretty huge load of code lines.  At first, this might seem to be very
discouraging : you do not understand what is what, you do not know if your are
going to break anything. And I have to say : I&rsquo;m still there. There are tons of
things through the application that I have not even heard of yet.</p>

<p>In this article I&rsquo;ll try to share with you some “techniques” I&rsquo;ve used to get
through with it and start to be more efficient with this kind of situation.
Bear in mind that those are not silver bullets, only hints to eventually get
yourself out of troubles.</p>

<!-- more -->


<h2>Use your toolkit</h2>

<p>First of all, trust your VCS, be it Git, Mercurial or even SVN. If your are
not very comfortable with it, now is a good time to learn how to properly use
it. Maybe not in depth, but at least just enough to be able to revert changes
you will make. This way, you won&rsquo;t feel bad about breaking anything at least.
By the way, if this is not already a good practice in your company, always
work on your own branch, to isolate your work and thus providing yourself with
extra confidence regarding modifications. And if your company does not use any
kind of VCS, <strong>get yourself out of there</strong> and find a new one!</p>

<h2>Wreak havoc!</h2>

<p>Now that you get your tools ready to repair any potential mistake, we can
start breaking things apart. I mean, not destroying the whole codebase. Only
some selected pieces so that you can mesure the impact of your modification.
The best way to understand what something does is to watch what happens when
it&rsquo;s not here anymore. This technique won&rsquo;t work hundred percent of the time,
but in most cases, it&rsquo;s a quick way to figure out what is what.</p>

<h2>Feel at home</h2>

<p>The final step will be refactoring. Once you&rsquo;re a bit more confident with the
codebase, start to moves things and reorganise it. You will most likely stumble
upon pieces of code that are not well factored. Tweak them to enhance both the
code and your <a href="http://tlarrieu.github.io/blog/2014/01/19/the-art-of-refactoring/">knowledge about it</a>.</p>

<h2>Bonus stage</h2>

<p>I should add that testing is also a great way to get informations about code.
First, by reading it, you can start to comprehend what it is supposed to do and
how it should behave. Then, it is also a good way to detect when you have
broken things around : use them during both the “wreak havoc” and the “feel
at home” phases.</p>

<p>I have something to confess though : I did not have the chance to use tests for
work yet.  The part of the code I have been working on is only partially
covered…</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Art of Refactoring]]></title>
    <link href="http://tlarrieu.github.io/blog/2014/01/19/the-art-of-refactoring/"/>
    <updated>2014-01-19T13:06:33+01:00</updated>
    <id>http://tlarrieu.github.io/blog/2014/01/19/the-art-of-refactoring</id>
    <content type="html"><![CDATA[<p>Refactoring, eventhough many agree upon the fact this is good practice, can get delicate to work with. Since refactoring does not add any feature to the current codebase, and because you often have “better things to do”, this phase can be postponed forever. The real question is “when is a good time to start refactoring things?”. A commonly accepted maxim states the following :</p>

<blockquote><p>“If it ain&rsquo;t broken, don&rsquo;t fix it.”</p></blockquote>

<!-- more -->


<p>Well, that&rsquo;s a start at least. But that&rsquo;s certainly not enough as well : you can not let your development be error-driven — or <a href="http://kriswager.blogspot.fr/2009/01/error-driven-software-development.html">can you</a>? In the previous <a href="http://tlarrieu.github.io/blog/2014/01/18/the-proper-tools-to-get-things-done">article</a>, I was talking about ergonomics. Refactoring is kind of related to that. In fact, any time you feel your are striving with the codebase might be a good time to refactor. I most certainly would add the following sentence :</p>

<blockquote><p>“If your code smells, now is a good time to refactor.”</p></blockquote>

<p>In my opinion, refactoring serves two purposes :</p>

<ul>
<li>It enhances your code quality</li>
<li>It forces you to see the code from a higher level, leaving you with a better understanding of the codebase.</li>
</ul>


<p>For practical insights about refactoring, I recommend checking those videos out :</p>

<p>Here is a talk from <a href="http://twitter.com/r00k">Ben Orenstein</a> — one of my favorite Ruby developer around here :  <a href="http://youtu.be/DC-pQPq0acs">Refactoring From Good to Great</a>.</p>

<p>And another one from John Pignata : <a href="http://youtu.be/q_qdWuCAkd8">Your Refactoring Cheat Sheet</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The proper tools to get things done]]></title>
    <link href="http://tlarrieu.github.io/blog/2014/01/18/the-proper-tools-to-get-things-done/"/>
    <updated>2014-01-18T22:57:25+01:00</updated>
    <id>http://tlarrieu.github.io/blog/2014/01/18/the-proper-tools-to-get-things-done</id>
    <content type="html"><![CDATA[<p>“ What is a good tool ? ” one might wonder. Here is a definition from <a href="http://en.wikipedia.org/">Wikipedia</a> :</p>

<blockquote><p>“Human factors and ergonomics (HF&amp;E) is a multidisciplinary field incorporating contributions from psychology, engineering, biomechanics, mechanobiology, industrial design, graphic design, statistics, operations research and anthropometry. In essence it is the study of designing equipment and devices that fit the human body and its cognitive abilities.”</p></blockquote>

<p>In short terms, one can say that a good tool is one that both enhances your productivity and increases your comfort.</p>

<p>In this article, I will cover the main tools I use on a daily basis. My intent is not to say that there are no others. Those float my boat, period.</p>

<!-- more -->


<h1>Tmux / Vim</h1>

<p>OK. This has been spoken of like a zillion time. Let&rsquo;s talk about it a zillion-and-one-th time.</p>

<h2>What are we talking about?</h2>

<h3>Vim</h3>

<p>Vim is a modal text editor. It means that it distinguishes several modes in the process of writing text. Among many modes, Vim lets you choose between :</p>

<ul>
<li>normal mode</li>
<li>insert mode</li>
<li>command mode</li>
</ul>


<p>Those are the three most basics on which others are built. <em>Normal</em> mode is the mode where you can explore and apply transformation (we&rsquo;ll come to that in a minute) to you&rsquo;re file through keyboard shortcuts (single-key or multi-key). <em>Insert</em> mode is your average text editor mode, where you boringly write text down. <em>Command</em> mode is the mode where you can unleash the full power of Vim and use some built-in (or plugged-in) functions.</p>

<p>There is one single statement that sums up best what Vim is all about : the thing you do the most while developing softwares is <strong>editing code</strong>, not <strong>writing</strong> new one. Why not use an editor that focuses on the first aspect?</p>

<p>I could spend a lifetime (almost literally) speaking about Vim. What made me realize what the true power of Vim was though, is the concept of <em>text objects</em>.
Text objects are  groups of characters that have a semantic connection. For instance, a letter is a text object. A word is a text object too. A sentence is a text object as well. A paragraph is a text object. A&hellip; Well, you get the idea.
The purpose of those text objects is for you to apply transformations on it : basically you can delete , replace or copy a text object. In fact, anything you can think of when it comes to editing text, you can do it quicker, better and in a more logical (yes, logical, you read correctly) way than with your average text editor.</p>

<p>If you want to learn more about this wonderful text editor, I recommend consulting the following resources :</p>

<ul>
<li><a href="http://vimcasts.org">Vimcast</a></li>
<li><a href="http://pragprog.com/book/dnvim/practical-vim">Practical Vim</a></li>
<li><a href="http://www.youtube.com/watch?v=SkdrYWhh-8s">Ben Orenstein&rsquo;s Write Code Faster : Expert Level Vim</a></li>
</ul>


<p>Those are on top of my head, don&rsquo;t be shy and explore the whole interwebz for yourself.</p>

<h3>Tmux</h3>

<p>Tmux is a <strong>T</strong>erminal <strong>Mu</strong>ltiple<strong>X</strong>er. In short, it means that it transforms your boring single windowed terminal into a rich, split-and-window-ful terminal. But it has more. It can broadcast your current session to any terminal able to reach your computer. It can be any other opened terminal on your machine or over a network connection. It can also save your current session for you to come back later. Finally, you can script it&rsquo;s behaviour to automate certain tasks that you do on a daily basis.</p>

<p>Once you get to know it, you can not live without it!</p>

<p>Here is a 30-ish minutes <a href="http://www.youtube.com/watch?v=9jzWDr24UHQ">talk</a> about how to achieve better productivity using both Vim and Tmux (it is aimed at Ruby developers but you can get some benefits viewing it nonetheless).</p>

<h1>Fish shell</h1>

<p>I do not have much to say about it other than CHECK THIS OUT : <a href="http://fishshell.com/">Fish Shell</a>.
If you still are not convinced after looking at all this beauty, there is nothing left I can do for you.
Seriously : GIVE. IT. A. TRY.</p>

<h1>Keyboards</h1>

<h2>Layout</h2>

<p>As you may know or may not know, QWERTY — like AZERTY and all the derivative — is a crappy keyboard layout. It has been specifically designed to make you type slower, in order to overcome technical deficiencies of early typewriters. As of now, in a time when we do not need this twist anymore, there is no reason in the world to keep using it. In fact, you have all the reasons to not use it. The earlier you make the switch, the better.
I will not lie to you. This will be hard and it might take time before you can even reach half of your current typing fluency. But I promise you will not regret the switch.
As I am French, I decided to go with BÉPO. This is a french oriented keyboard layout, inspired by projects like dvorak and colemak.</p>

<p>If you want to know more about alternative keyboard layouts, please follow those links :</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Dvorak_Simplified_Keyboard">Dvorak</a></li>
<li><a href="http://colemak.com/">Colemak</a></li>
<li><a href="http://bepo.fr/wiki/Accueil">Bépo</a></li>
</ul>


<p>Those are not the only ones, but they are the most known.</p>

<h2>Device</h2>

<p>Last, but not least in any way, we are going to speak about physical keyboards. Most of you are certainly writing on a &ldquo;standard&rdquo; <a href="http://en.wikipedia.org/wiki/Keyboard_technology#Dome-switch_keyboard">rubber dome</a> keyboard (or on a <a href="http://en.wikipedia.org/wiki/Keyboard_technology#Scissor-switch_keyboard">scissors switch</a> keyboard for those of you who use a laptop).</p>

<p>Let&rsquo;s be honest : those are not the best. If you are looking for higher end keyboards, you should look out for either a mechanical keyboard or a capacitive keyboard. First, they last longer. Then, they have a waaaay better feel. Of course, they do come in a higher price as well. But when you are spending something like eight hours a day typing stuff, would not you like to have a comfortable experience ? I definitely do.</p>

<p>Here are a few resources on that specific topic :</p>

<ul>
<li><a href="http://deskthority.net/">Deskthority</a></li>
<li><a href="http://geekhack.org/">Geekhack</a></li>
</ul>


<p>You might also want to look into what are called “ergonomic keyboards”. I personally do not like them, but you might.</p>

<p>And for those who wonder, here is my keyboard :</p>

<p><img src="http://i.imgur.com/pN772Dz.jpg" alt="keyboard" /></p>

<p>This is a Poker II (ANSI layout) and yeah, the space bar is upside down — as the two modifiers beside it.</p>

<p><strong>[Update (2014.09.23)]</strong></p>

<p>A few months ago, I got a new keyboard : the <a href="http://en.wikipedia.org/wiki/Happy_Hacking_Keyboard">HHKB</a>.</p>

<p>Here&rsquo;s a picture of it :</p>

<p><img src="http://i.imgur.com/XrO2gM2.jpg" alt="hhkb" /></p>

<p>Space bar and modifiers around it are still upside down, I&rsquo;m loving it!</p>
]]></content>
  </entry>
  
</feed>
